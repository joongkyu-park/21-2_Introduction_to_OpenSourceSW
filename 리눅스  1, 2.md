# 리눅스  1, 2

1장

4)
커널
: 운영체제의 핵심적인 프로그램.
운영체제는 부팅될 때 제일 먼저 커널을 메모리에 로딩.
컴퓨터가 꺼질 때 까지 메모리에 상주.
-> on booting

유틸리티
: 사용자가 실행했을 때(런타임에) 로딩된다.
일반적인 프로그램
-> on demand

쉘 프로그램
: 유틸리티, 그러나 special-purpose. 다른 프로그램들(유틸리티들)을 실행하기 위한 유틸리티.
역시 on demand
사용자로부터 type된 커맨드를 읽고, 그 입력된 커맨드들을 인터프리트해서 다른 유틸리티를 실행할 수 있도록 커널에 요청, 시스템콜을 사용하여.
따라서 쉘은 중간다리 역할을 함. job control한다, comand line interpreter라고도 함.
->평소에쓰던 cli가 곧 bash이고 곧 쉘 프로그램임

5)
여러종류의 쉘.
최근에는 대부분 bash shell을 사용. 대부분의 기능들을 포함.

7)
쉘 프로그램 장점
사용하기 쉽다
다른 언어의 코드들을 붙이기 쉽다

단점
느리다(불필요한 프로세스를 만들고 그 프로세스랑 통신하기 하느라 오버헤드..) -> 성능 기대 x
문법 오류가 많이날 수 있다.

8)
쉘 변수
자유롭게 만들고 해지할 수 있다.
기본적으로 만들어진 변수도 있다. e.g. HOME = /home/usr -> 홈 디렉토리를 저장하는 변수

9)
환경변수
쉘 변수중에서 자식에게 되물림됨 -> 즉 자식 프로세스에게 전달된다.
부모프로세스로부터 “copy”된 쉘 변수들을 환경변수라고 한다.
따라서 환경변수를 수정하면 부모프로세스에겐 영향x, 그러나 자식프로세스를 만들게 되면 그 자식프로세스에겐 영향
쉘도 유틸리티이므로, 쉘을 통해 다른 프로그램을 실행시키면 자식프로세스가 되는건데, 쉘의 환경변수가 전달되겠다.

built-in 환경변수들
리눅스에 내장된 환경변수들(e.g. PATH, HOME, PWD …)
프로그램들에게 영향을 줄 수 있어 중요함
-> 관습적으로 대문자로.
로컬 변수 : 환경변수가 아닌 변수들. 현재 프로세스에만 영향을 주는 쉘변수 

10)
쉘 변수를 어떻게 만들고 사용하는지 보자.

타입이 정해지있지 않고 모두 문자열로 취급 -> untyped

공백x
대소문자구분
echo 커맨드를 통해 변수값 출력가능

변수를 정의할 때는 $기호가 없고,
사용할 때는 $기호가 있다.

set : 현재 쉘 변수들을 모두 display하는 명령어.

+)
_my=
처럼 값을 넣지않으면 변수는 만들어지나 null값이 들어감

12)
unset 명령어로 변수삭제 가능

grep : 입력으로 받은 특정한 문자열을 찾는 명령어

13)
export를 통해 환경변수를 만들 수 있음

이 환경변수들은 자식들에게 영향을 준다

14)
지역변수와 환경변수에의 차이 예시

15)
export -n
환경변수를 지역변수로 만들기

16)
bash에서 또 bash를 하면 자식 쉘이 됨.
다시 부모로 올려면 exit

17)
내장환경변수들

18)
PATH
: 을 기준으로, 쉘이 명령어들을 찾을 때 관련한 디렉토리 리스트들을 보여줌
![리눅스  1, 2](images/리눅스%20%201,%202.png)

그래서 환경변수를 임의로 바꾸게되면,
명령어들을 찾을수가 없게된다

PATH에 새로운 경로를 추가하고 싶을때
![리눅스  1, 2-1](images/리눅스%20%201,%202-1.png)

19)
HOME
현재 계정과 관련된 홈 디렉토리를 보여줌
cd 명령어에서 쓰임

추가된 환경변수들은 터미널을 끄면 다 사라지는데,
지속적으로 유지하고 싶으면 현재 디렉토리에있는 ~/.bashrc 파일에 저장해야한다.

+)pwd 명령어 : print working directory 의 준말, 현재 작업 중인 디렉터리의 이름을 출력

2장.
명령어의 확장과 치환

3)
확장과 치환

리눅스에 명령어 입력 시, 바로 실행되는게 아니라
bash, 즉 쉘이 명령어를 tokenize하고 스캔해서 특별한 원소가 있는지 살펴본다(키워드라던가 메타캐릭터 같은것들).
그걸보고 변경을해서 새로운 문자열로 변경하게 된다.
-> 이런 것들 확장 또는 치환 된다고 한다.(혼용됨)

![리눅스  1, 2-2](images/리눅스%20%201,%202-2.png)

확장과 치환은 이 순서대로 이루어진다

4)
Brace Expansion
확장, 치환 중 가장 먼저 일어나는 작업
brace(중괄호 {, }를 의미)를 통해 문자열을 확장

단일 항목인 경우 확장x
공백있을경우 확장x

brace를 다중으로 사용할 경우 카티션곱의 형태로 확장적으로 만들어짐
![리눅스  1, 2-3](images/리눅스%20%201,%202-3.png)

.. 은 range를 표현
숫자와 문자를 표현해 range 표현하면 확장x

..를 한번 더 사용하면 stride가 된다.

![리눅스  1, 2-4](images/리눅스%20%201,%202-4.png)

이렇게하면 2씩 감소

5)
다음과같이 다중으로 사용할 때 막강한 효과를 지님
다음과 같이 26*10개의 문자열 패턴을 한문장으로 나타낼 수 있음

컴마로 연결되면 순서대로 출력됨

![리눅스  1, 2-5](images/리눅스%20%201,%202-5.png)

활용예
- 1~6까지의 파일을 만들겠다
- foo부터 dog까지 서브디렉토리 5개를 만들겠다
- 3개의 파일을 생성하겠다

주의 : brace expansion은 확장과 치환중 가장 먼저 일어난다.
![리눅스  1, 2-6](images/리눅스%20%201,%202-6.png)

6)
Tilde 확장
 
~ 확장과 HOME변수는 같은 뜻.
~+ : 현재 디렉토리 의미 -> PWD
~- : 이전 현재 디렉토리 의미 -> OLDPWD

7)
Parameter 확장(변수 치환이라고도 부름)
$뒤에 변수명을 주면 변수에 해당하는 값으로 치환돼서 전달됨

$변수 or ${변수} <- 이건 brace expansion이 아님

8)
파라메터 확장에서
변수명이 정의가 안되거나 null일 수 있다.
${변수명:-디폴트값} -> 디폴트 값을 지정할 수 있음(unset이거나 null이면 디폴트값 사용해라)
${변수명-디폴트값} -> 콜론이 없으면 unset일 때만 사용하겠다는 뜻. null일 땐 null로 표현하겠다는 뜻

9)
Command Substitution
명령어의 결과로 확장

whoami : 유저의 이름을 알려주는 명령어

중첩된 구조를 사용할 때는 ` 이 기호는 사용불가

; 을 이용해 구분해서 2개의 명령어 같이 사용가능

10)
산술확장

산술의 결과값으로 확장

대괄호 표현보단 가급적 $((expression)) 으로

$(( )) 여기 안에선 $ 사인이없어도 변수로 취급⭐️
 
expr : 산술연산을 할 수 있는 명령어

11)
$을 이용한 확장과 치환 정리

+)
쉘은 cpp 문법과 비슷한 점이 많다
e.g.)
x = 5
x++ -> x는 6이다

12)
파일이름 확장

wildcard : 존재하는 파일이름에서 어떠한 패턴을 표현하기 위한 특별한 기호. glob이라고도 부름

* : 0개이상의 문자열과 매칭(현재 존재하고있는 워킹 디렉토리에서)

? : 어떤 character가 와도 좋으나 딱 1개문자.

[…] : 대괄호 안의 캐릭터들 중에 1개
e.g) $ ls [abc]* : a 또는 b 또는 c 중에 1개 로 시작하는 모든 파일들 이름 출력

13)
예제

⭐️와일드카드같은경우 매칭되지 않으면 filename expansion이 일어나지 x -> 확장은 존재하는 파일에서 일어남.
![리눅스  1, 2-7](images/리눅스%20%201,%202-7.png)

이 경우 파일이 존재하지 않기때문에 확장 일어나지 x

14)
확장과 치환에서,
가장 먼저 일어나는 것 -> brace expansion
가장 나중에 일어나는 것 -> filename expansion
![리눅스  1, 2-8](images/리눅스%20%201,%202-8.png)

 15)
![리눅스  1, 2-9](images/리눅스%20%201,%202-9.png)

ls *t : t로 끝나는 파일들

16)
메타캐릭터
특별한 기능으로 사용할 수 있는 기호들

17)
quotes
쉘에서 메타캐릭터를 특별한 기능이 아닌 그 기호 그대로 사용하려면
“ “ 또는 ‘ ‘을 사용.
-> quotes 안을 문자열로 처리

일반적인 프로그래밍 언어에서 문자열을 나타낼 때 위 기호를 쓰지만
쉘에선 기본적으로 모두 문자열로 받아들이기 때문에
quotes 기호가 있던 없던 문자열로 받아들인다.(quotes가 있어도 문자열, 없어도 문자열)
![리눅스  1, 2-10](images/리눅스%20%201,%202-10.png)

+) 공백(white space)도 파일(또는 디렉토리)를 구문해주는 메타캐릭터

18)
quoting rules

메타캐릭터같은 특별한 캐릭터들의 의미를 없애고 문자그대로 bypass하는 것

- Escape character ₩(또는 \)뒤에 캐릭터를 붙이면 의미 사라지게해줌
- single quote quote 내에 모든걸 bypass
- double quote quote 내에 모든걸 bypass해주나 예외가 있음 그 예외는 20페이지에서

19)
예시

20)
single quote vs double quote
single quote는 강력하다! strong quotes

double quote의 2가지 예외
변수확장, 명령어 치환

