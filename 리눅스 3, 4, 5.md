# 리눅스 3, 4, 5

3)
쉘 옵션 변경 방법 2가지
1. set
2. shopt

set -o : 설정가능한 옵션 보여줌
set -o 옵션이름 : 옵션 on
set +o 옵션이름 : 옵션 off

shopt -s : on
shopt -u : off

| column : 2줄로 보여주게하는 명령어

alias : 명령어 별칭 설정

4)
리눅스 명령어 종류와 형태

compgen -c : 리눅스 명령어 리스트를 나열

alias : 긴 명령어같은 경우 별칭을 설정하여 설정
	->  어떤 명령어나 함수보다 우선순위가 높다

keyword -> 다음주에!
function -> 다음주에!

built-ins : 쉘 자체에 내장되서 제공되는 명령어
내장되어있으므로 외부명령어와 다르게 프로세스 만들지 않아도 되고 파일시스템에 접근안해도됨

external command : 외부명령어

5)
명령어들의 이름이 중복될 수 있다.
-> 명령어의 실행순서에 따라 실행됨
![리눅스 3, 4, 5](images/리눅스%203,%204,%205.png)

alias가 가장 우선순위 높고
외부 명령어가 가장 우선순위 낮다

type 명령어 : 명령어의 종류 출력
type -a 명령어 : 중복된 명령어도 있다면 모두 출력
![리눅스 3, 4, 5-1](images/리눅스%203,%204,%205-1.png)

6)
내장 vs 외부 명령어

내장명령어 : 쉘 프로그램의 내부 명령어

배쉬프로그램은 내부함수로 구현되어있다고 볼 수 있다.

내장명령어의 경우 배쉬가 새로운 프로세스를 만들어서 fork나 exec하는게 아니라 함수를 직접적으로 실행하는 형태
-> 좀더 효율적으로 동작

상태정보를 수정하는데 내장명령어가 사용된다.
만약 외부 명령어를 통해 수행된다면, 자식프로세스가 만들어질 것이고
자식 프로세스의 환경변수는 부모프로세스에게 영향을 미칠 수 없겠다.

만약 cd가 외부명령어였다면?
![리눅스 3, 4, 5-2](images/리눅스%203,%204,%205-2.png)

cd는 현재 디렉토리의 경로를 담는 pwd를 수정하는것인데,
외부명령어라면 자식프로세스를 만들어서 pwd를 수정해도 부모프로세스에 반영되지 않기 때문에 변화가 없다.

내장명령어에서도 찾지 못하면 외부명령어를 찾는다(우선순위 가장 낮음)
PATH를 탐색하게 되는데, 디스크를 탐색하는 과정임.
![리눅스 3, 4, 5-3](images/리눅스%203,%204,%205-3.png)

콜론으로 구분된 경로들을 왼쪽에서 오른쪽으로 탐색
-> 시간이 상대적으로 오래걸린다

7)
type -t : 명령어가 빌트인진지 외부명령어인지 alias인지.. 출력

type -p : 경로도 알 수 있다

8)
명령어 리스트
; 이나 & 을 통해 여러 작업을(job) 이어서 순차적으로 실행할 수 있다.

; 으로 명령어를 이으면 동기적으로 실행.
앞의 명령어의 실행의 다 끝나야 다음 명령어 실행.
부모가 자식프로세스들을 만들고 하나하나 순차적으로 실행

& 으로 명령어를 비동기적으로 실행
따라서 어떤 명령어가 먼저 실행할지 모장할 수 없음.
부모가 자식프로세스들을 병렬적으로 실행
부모프로세스(쉘은) 프로세스를 실행시켜놓고 사용자의 다른 명령어를 받을 수 있고,
자식 프로세스들은 후면에서(백그라운드)에서 실행되고 있게 된다.

9)
Exit status(종료상태)

프로세스는 종료상태의 값을 가진다.
0이면 성공적인 종료, 0이 아니면 에러를 가지게 되는 것

$? : 종료상태값을 확인하기 위해 사용

10)
Conditional Command list

Exit status의 활용
![리눅스 3, 4, 5-4](images/리눅스%203,%204,%205-4.png)

->  ls ~/.basshrc 이어야 cat ~/.bashrc을 실행하겠다는 의미

삭제같은 경우 위험하기 때문에 요긴하게 사용가능
다음과같이 change directory가 성공했을 때만 삭제진행
![리눅스 3, 4, 5-5](images/리눅스%203,%204,%205-5.png)

||은 앞의 조건이 false일 때 뒤에 명령을 실행하도록(이해?)
![리눅스 3, 4, 5-6](images/리눅스%203,%204,%205-6.png)

11)
커맨드리스트는 그룹화하여 서브쉘로 실행가능

소괄호로 묶어서 명령어를 실행하면 fork 프로세스 에서 실행,
중괄호로 묶어서 명령어를 실행하면 current 프로세스(쉘)에서 실행

12)
디스크의 파일이나 디바이스를 통일된 방식으로 다루기위해 file로 관리한다

프로세스는 파일을 열때마다 인덱스를 부여, 그 인덱스가 file descriptor
file descriptor table : file descriptor를 관리하는 table

표준적으로 3개의 파일이 오픈되어 실행
![리눅스 3, 4, 5-7](images/리눅스%203,%204,%205-7.png)

13)
Redirection

wc, sort, bc와 같이 표준입력(standard input)을 필요로하는 기능들이 있다

wc: 라인의 수 , 워드의 수, 캐릭터의 수 출력
sort : 입력을 정렬해서 출력
bc : 계산기
head(tail) : 앞(뒤)에서 원하는 라인만큼 출력

0번스트림(스탠다드 인풋)을 file로 redirect하기
-> 즉 키보드로부터 입력받아야하는 것을 파일로 입력받겠다는 뜻
0< : 스탠다드 표준입력이 아니라 파일로부터 입력을 받고 싶을경우 사용
0을 생략해도 가능

14)
이번엔 1번스트림(스탠다드 아웃풋)을 file로 redirect하기
-> 즉 스크린으로 출력될 것을 파일로 바꾸어준다는 뜻
1>  기호 사용
1>> : append 기능(원래 있던 파일에 내용 추가)

위와 같이 1을 생략해도 가능

15)
스탠다드 에러도 파일로 redirect가능(3번스트림)
-> 즉 에러출력을 파일로 만들어줌
![리눅스 3, 4, 5-8](images/리눅스%203,%204,%205-8.png)

① : 정상실행되는 명령어
② : 에러를 출력하는 명령어

2>만 사용할시 ①은 출력되고, 에러내용만 파일로 만듬
>만 사용할시 에러내용은 출력되고, 정상실행된 내용은 파일로

2>와 > 동시에 사용도 가능

16)
스탠다드 인풋, 아웃풋의 redirect 같이 사용하기

$ cat > calc.txt
: 사용자에게 입력을 받고, 그 결과를 calc.txt파일로 저장

$ bc -l < calc.txt > result.txt
: 계산기를 사용하는데, calc.txt로 입력을 받고 result.txt에 출력내용 저장
순서는 바뀌어도 상관없ㅇ므

![리눅스 3, 4, 5-9](images/리눅스%203,%204,%205-9.png)

이 명령어는 file1의 내용을 file2로 복사하는 기능과 동일하기 때문에
cp 명령어와 동일하다(우리의 강의선 배우지 않은 명령어)

17)
redirection 추가내용

현재 폴더에 a라는 파일만 있다고 했을때,
![리눅스 3, 4, 5-10](images/리눅스%203,%204,%205-10.png)

다음과 같이 출력될 것.

저 두 개의 출력을 같은 파일에 넣기
$ ls a b > log.txt 2>&1
: 정상출력을 log.txt에 작성하고 에러출력도 1번스트림(정상출력)에 같이 작성하라

같은 뜻으로
% ls a b &> log.txt
으로 사용할 수 있다.

$ ls a b > log.txt 2>&1에서 &을 빼고
$ ls a b > log.txt 2>1
으로 하면 1이라는 이름으 파일이름으로 인식해서 에러내용을 1이라는 파일에 작성하게 되겠다
![리눅스 3, 4, 5-11](images/리눅스%203,%204,%205-11.png)

아웃풋을 없애버리고 싶을때
/dev/null 경로에 출력을 저장하면 바로 폐기된다

4. 파이프와 쉘 스크립트

3)
pipe -> | 기호

파이프 왼쪽 명령어의 표준출력이 오른쪽 명령어의 표준 입력으로 들어가는 형태.
일종의 모듈화를 시켜준다고 볼 수 있다. 왜냐하면 기존의 명령들을 파이프를 통해 엮어 새로운 명령을 만들 수 있다는 관점에서.
-> 확장성을 가질 수 있다.

-n : 문자가 아닌 숫자로 처리해라

4)
Filter : 표준입력과 출력을 둘다 가지는 명령어

파이프의 맨왼쪽 명령어는 표준출력만 있어도 되지만 그다음 명령어부터는 표준입력과 출력을 모두 가진 필터 명령어들만 올 수 있겠다.

cut : 파일내용의 일부를 가져와서 출력
-d: 구분자 지정
-f1 : 구분자로 나뉘어진 것들 중 첫번째 것들 가져옴(0이아닌 1이 첫번째)
	-> 첫번째 필드를 가져오라는 의미

![리눅스 3, 4, 5-12](images/리눅스%203,%204,%205-12.png)

passwd 파일을 | 콜론(:)구분자로 구분하고 첫번째 원소들만 가져와서 | sort하여서 | 개수를 세어서 출력

5)
필터 명령어의 대표적인 예, cut
파일이나 표준입력으로 입력받아 문자나 필드 단위로 사용자가 원하는 데이터를 추출하여 출력

필드는 데이터베이스 릴레이션으로 생각했을 때 attribute부분
![리눅스 3, 4, 5-13](images/리눅스%203,%204,%205-13.png)

![리눅스 3, 4, 5-14](images/리눅스%203,%204,%205-14.png)

cut은 입력을 받아야하는데, 이건 파일을 통해서 입력을 받는 예시.
입력할 파일을 맨뒤에 쓴다.

-c : 문자별로 가져오기
-10 : 처음부터 10개 문자
10-20 : 10~20 range의 문자

6)
tr : 문자를 삭제나 변환해주는 명령어
tr ‘bd’ ‘*’ : bd를 *로 변환해라
tr -d ‘bd’ : bd를 삭제해라
tr -d [:blank:] : tap , white space 등 공백 전부 삭제

![리눅스 3, 4, 5-15](images/리눅스%203,%204,%205-15.png)

PATH 변수를 | 콜론을 \n으로 대체
-> 컴포넌트들이 한줄씩 되어있을껏
그걸 라인별로 카운트하니까
-> 컴포넌트의 수 출력

7)
awk 프로그램
데이터포맷의 형태는 다양하기 때문에 cut은 한계가 있다
텍스트형태의 데이터가 주어졌을때 필드와 레코드별로 데이터를 처리해서 출력해준다
리눅스에서 표준도구임
awk은 기본적으로 pattern(조건)과 action(동작)의 순서쌍

$1 : 첫번째 필드를 의미

![리눅스 3, 4, 5-16](images/리눅스%203,%204,%205-16.png)

패턴 : 3번째 필드의 값이 0보다 클때
액션 : 1, 2, 3번째 필드 값을 출력해라

![리눅스 3, 4, 5-17](images/리눅스%203,%204,%205-17.png)

3번째를 보면 곱하기같은 cpp의 문법도 확장적으로 사용할 수 있다는 큰 장점.

8)
NF : 필드 개수
NR : 현재 레코드의 번호
![리눅스 3, 4, 5-18](images/리눅스%203,%204,%205-18.png)

printf : 원하는 출력형태의 format을 통해 출력가능 (%d, %s …)

9)
awk은 다양한 형태의 연산자를 통해 무궁무진하게 확장될 수 있다

![리눅스 3, 4, 5-19](images/리눅스%203,%204,%205-19.png)

~ : 다음을 포함하면 True
$1~”Son” : 1번째 필드값이 “Son”을 포함하면 조건만족

10)
awk 예제

![리눅스 3, 4, 5-20](images/리눅스%203,%204,%205-20.png)

두 예시 다 잘 봐야함

+)
2번째의 경우 cut을 쓰면 tr을 통해 공백을 제거해주고,, 복잡하겠지만 
awk를 쓰면 직관적으로 쉽게 사용가능

11)
예제2
문제, 답변
![리눅스 3, 4, 5-21](images/리눅스%203,%204,%205-21.png)

12)
Alias
리다이렉션, 파이프, 커맨드리스트 등의 것들을 긴 명령어기때문에 alias를 통해 하나의 별칭으로 바꾸어줄수 있다

13)
쉘 스크립트

First Script : 여러개의 명령어들을 하나의 스크립트로 처리

쉘스크립트를 실행하면 새로운 프로세스를 만들어서 서브쉘에서 수행이된다.

#!/bin/bash : 쉘스크립트가 어떤 인터프리터에 의해서 시작될지 지정해주는 것. 쉘스크립트 실행시 반드시 첫번째문장에 와야함
#! : shabang. 매직넘버의 한 종류

이후 원하는 명령어들을 적어준다.
#을 통해서 주석도 쓸 수 있음

chmod : 모드변경
+x : 모두에게 실행권한을 줌
hello.sh : 쉘스크립트 생성

./hello.sh : 쉘스크립트 실행

14)
Positional Parameters
쉘스크립트에 인자를 전달하는 방법

Positional Parameters는 쉘프로그램의 변수
쉘프로그램이 실행될 때 커맨드라인으로부터 명시된 인자들이 세팅된다.

$기호를 통해 인자를 전달,
한자리수면 중괄호 생략가능, 두자리 이상부터는 ${10}과 같이 중괄호 필요

![리눅스 3, 4, 5-22](images/리눅스%203,%204,%205-22.png)

다음과 같이 사용자가 전달한 인자를 쉘스크립트에서 사용할 수 있다

15)
특별한 파라메터들
$0 : 쉘스크립트이름
$# : 포지셔널 파라메터의 개수
$* : 모든 포지셔널 전부 리턴
$? : 가장 최근에 실행한 명령어
$$ : 현재 프로세스의 pid
$PPID : 부모 프로세스의 pid

16)
예시 1

tar -cvf sample.tgz ./test
: 압축시킴 sample.tgz로, ./test 경로에
tar -xvf : 압축해제

17)
예시 2

예시들 반드시 이해하고 잘 살펴보기

18)
쉘 스크립트 프로그램 수행중에 동적으로 사용자에게 입력받기

read 변수명 : 사용자로부터 받은 값을 저장
-s : 비밀번호같은거 입력할때 안보이게 하기 위해
-t10 : 10초의 시간이 흐르면 사용자의 입력이 없어더라도 넘어감
-p “~~”: 프롬프트를 적을 수 있음

19)
예시

5. Conditional Construct

3)
test command
어떤 식이 true냐 false냐 를 결정하는 구문
if이나 loop문의 조건식으로 활용

커맨드
test expression
[expression]

중요!
쉘 스크립트에선,
0 -> true (정상종료)
다른 숫자 -> false

커맨드의 결과, 판단결과보기
$?

test 표현은 다양한 오퍼레이터들을 이용할 수 있다
test -gt : grater than
test -lt : less than
test -eq : equal
-> test 대신에 전체 커맨드에 [ ] 씌워도 같은 뜻!

4)
test표현의 다양한 오퍼레이터들

정수비교할 때 쓰는 오퍼레이터들

5)
파일 테스트를 위해서도 다양한 오퍼레이터 있다

-f -> 레귤러 파일이어야함. 디렉토리는 x (-e 와 다른점)

-b, -c
파일에 여러 디바이스 파일이 존재할 수 있다.
크게 캐릭터 디바이스, 블록 디바이스
디바이스도 리눅스에선 파일로 취급
그때 사용

-> -e, -d, -f 만 외워라

6)
문자열 비교 오퍼레이터

7)
컴파운드 커맨드
compgen -k : 컴파운드커맨드로 사용할 수 있는 여러 키워드들
여러 명령어들을 복합적으로 사용해서 하나의 명령어처럼 사용하는 것들

8)
if커맨드
if로 시작해서 then, elf, else .. , fi로 끝나는 커맨드
-> 키워드로 시작해서 키워드로 끝난다

; 등을 통해서 한문장으로 구성할 수 있다

![리눅스 3, 4, 5-23](images/리눅스%203,%204,%205-23.png)

ls &> /dev/null : redirection인데 엔드가 있으면 표준출력이나 에러 모두   null 디바이스로 보내기때문에 아무것도 출력이안된다
그런데 인자가 없으니까 보통 ls하면 성공이다.

두번째는 xx라는 파일이 없으므로 실패

true는 항상 0 반환, false 1 반환

9)
if문 과 테스트 결합 예시
![리눅스 3, 4, 5-24](images/리눅스%203,%204,%205-24.png)

$# : 인자의 수

10)
답
test $1 -gt 0
또는
[$1 -gt 0]

11)
문자열 테스팅 예제

12)
echo를 하면 뉴라인으로 넘어가지만
입력을 받을 땐 보통 뉴라인으로 넘어가지 않게 해줌 -> -n

13)
read -p : echo -n이랑 read를 합친거

if [$op = add]

elif [$op = sub]

14)
파일 테스팅
![리눅스 3, 4, 5-25](images/리눅스%203,%204,%205-25.png)

15)
파일테스팅 실제예시

.(source) : current shell에서실행시키라는 의미. 그냥 실행하면 서브쉘에서 실행됨

![리눅스 3, 4, 5-26](images/리눅스%203,%204,%205-26.png)

이부분 내용 헷갈리면 강의 다시 참조

16)
케이스 구문

17)
케이스 패턴에서 와일드카드를 사용하는 예시

18)
패턴매칭에서는 와일드카드가 사용가능하다
또 파이프라인을 사용해서 여러 개를 선택할 수 있게 해줄 수 있다.

