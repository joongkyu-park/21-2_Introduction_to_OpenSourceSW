# 오픈소스 6주차(OSS 3,4)

2)
오픈소스를 활용해서 프로젝트를 수행할 때 각 개발과정에서 필요한 다양한 도구들.
-> 오늘 수업 : 왜 그 도구를이 필요한것인가에 대해 이해에 초점
![오픈소스 6주차(OSS 3,4)](images/오픈소스%206주차(OSS%203,4).png)

특히 3개의 integration의 차이가 무엇이고
version control system이 왜 필요한지

3)
오픈소스 라이센스

오픈소스 라이센스의 분포를 알려주는 통계자료
점차 permissive 라이센스의 비중이 높아지고 있다.

4)
오픈소스를 활용하고자 할 때 찾는 방법

5)
예시
블랙 덕 오픈 허브(Ohloh라고 불림)
오픈소스 소프트웨어 개발 커뮤니티를 찾을 수 있게 도와주는 웹서비스 제공

6)

7)
오픈소스 컴포넌트를 잠재적인 문제를 찾는 방법(라이센스를 중심으로)

최근 법적인 분쟁때문에 라이센스 compliance 문제를 준수하는 것을 중요하게 생각됨
그중에 많이 사용 되는것 :  Fossology, Protex, CodeEyes(한국저작권위원회에서 제공해주는거)
	-> 내가 어떤 소프트웨어를 올리면 그 소프트웨어안에 오픈소스 컴포넌트가 있는디 스캔해주고, 그 오픈소스 소프트웨어의 프로파일, 특징 특히 라이센스 정보를 reporting해준다.

8)
오픈소스소프트웨어를 사용할때 항상 최신을 사용하는것은 아니고,
프로젝트와 가장 적합한, 안정된 버전을 찾게 될 수 있다.
그럴 때 오픈소스의 패치가 되지 않았는지, 되었는지를 확인할 필요가 있다.
따라서 취약점 분석을 위해 사용되는 도구들. ex. NVD …

9)
소프트웨어 개발 도구들

오픈소스를 활용해서 대규모의 프로젝트를 진행하려고 할 때,
제일 먼저 해야할 것은 현존하는 가장 좋은 도구들을 찾아내야한다.
…

이러한 개발도구들은 말그대로 도구이기때문에
너무 사용법이나 기능에 대한 요구사항을 확인하는데 시간을 쏟으면 안되겠다.

10)
소프트웨어 개발도구를 선정할때 소프트웨어의 품질관리가 중요하다.
소프트웨어의 품질에서 error management가 중요,
그것을 위해서 error의 특징을 살펴보자.

fault: 에러의 첫번째 근본 원인으로 사용하는 용어

…
에러는 propagation이 되기때문에 되도록 빨리 찾고 해결해야한다.
특히 대규모시스템에서는 관련된 모듈이 많기 때문에 fault와 연관된 모듈이 많아지고 디버깅해야하는 파일 수가 많아진다 -> 소프트웨어 품질저하 및 개발비용 증가의 원인

11)
따라서 에러가 만들어지고 나서 찾아지는데 까지 시간이 지연되면
디버깅하는 비용이 굉장히 증가할 수 있다.
…

12)
Lint
컴파일러나 인터프리터로 문법적인 오류를 찾는것 이외에 더 다양한 에러를 탐지위해 제공되는 대표적인 도구

13)
에러탐지 이외에도 코드리뷰를 통해 다음과 같은 목표들을 달성시키길 원한다
![오픈소스 6주차(OSS 3,4)-1](images/오픈소스%206주차(OSS%203,4)-1.png)

14)
이슈를 관리하는 시스템, 이슈트랙킹 시스템
이슈를 매니지 하는 도구들.

다양한 개발단계에서 여러 이슈들이 나온다.
여기서는 에러측면의 이슈를 예시.

Unit Test : 자기자신이 만든 코드를 테스트
Integration Test : 다른 모듈과 통합해서 테스트

15)
얼마나 자주 Integration해야하는가?  오늘핵심⭐️

Phased integration
각 모듈들을 개발하고, 한번에 통합하는 전통적 방식.
한번에 통합하고 한번에 테스트하고 한번에 디버깅

이전에 테스트가 된적이 없기때문에 한번에 버그들이 나타난다는 문제점.
테스트가 안된 클래스라던지, 클래스 사이의 인터페이스 문제라던지 등 여러 문제등이 한번에 쏟아져 나오기 때문에 디버깅이 어렵다.

예를 들어 2개의 파일을 만들고, 2개의 파일에서 서로다른 버그가 있을때
에러는 propagation되는 특징이 있다.
이 버그들이 혼재되어 나타나면, 분석해야할 디버깅해야할 파일의 수가 굉장히 많고 복합적으로 나타나기 때문에 개발유지보수비용이 증가하는 문제점이 있다

16)
그래서 나온 방법
Incremental Integration
한 번에 하나의 파일만 통합하자.

처음에는 아주 작고 핵심부분(skeleton)을 만들어놓고,
거기에 하나씩 하나씩 모듈이 추가될때마다 통합해나가는 방식.
하나 만들고 통합하고 테스트하고, …. 하나씩 하나씩 점진적으로 통합해 나가는 방식

장점
하나씩 통합하니까 어떤 파일이 하나 추가되었을 때 버그가 여러군데 나타났다
-> 이것의 근본원인, 진짜에러인 fault를 찾아내는게 쉽다.
또 Unit 테스트를 할때 전체 시스템과 통합해서 테스트하기 때문에 좀 더 잘 테스트가 된다.
또 확실하게 명백하게 되는지 안되는지를 진행상황을 모니터링 할 수 있다. 
마치 눈덩이 굴러듯이 개발해나가는 방법

17)
대규모의 소프트웨어의 경우 모듈이 많다.
그럼 스켈레톤에 어떤 모듈부터 점진적으로 통합할것인가가 위 방법의 가장 중요한 이슈.
이런 전략, 순서를 정해야한다.

모듈이 계층구조를 가지고 있을때, 상위의 하이레벨 모듈들은 conceptual한 디자인적인 요소를 담고 있고, 하위의 로우레벨 모듈들은 상대적으로 구현이슈, 실질적인 요구사항을 담고 있다.
만약에 바텀업 방식으로 밑에서 위로 올라간다고 하면, 상위레벨의 디자인이 변경될 수 있고
위에서 밑으로 내려오면 구현적인 이슈에 문제가 발생할 수 있다
따라서 중간단계의 하이브리드한 통합방식들이 제안되고 활용되고있다.
Sandwich Integration : 상위레벨 -> 하위레벨 -> 중간레벨
Risk-oriented integration : 리스크 별로 분류하여 상대적으로 challenging한 문제들부터 해결해나감
Feature-oriented integration : 논리적인 기능으로 나누어서 feature 중심으로 분류 할 수 있다.

뭐가 좋고 나쁘다 보다는 각 프로젝트에 맞는 좋은 전략을 찾자

18)
Incremental Integration은 Daily Build라고도 언급된다
모듈이 굉장히 큰 소프트웨어 같은 경우, 모듈이 많기 때문에 점진적으로 통합해나가기 위해선 거의 매일 combine해나가야 한다는것을 의미. 부지런히 통합해나가야한다.

이렇게 Daily Build와 함께 사용되는 테스트 -> 스모크 테스트
여러 테스트 방법 중 하나인데, 프로그램의 핵심적인 기능만 보는 테스트.

데일리빌드와 스모크테스트를 통해서 소프트웨어를 계속 좋은 상태의 품질을 유지하게 되고 버그도 쉽게 찾을 수 있는 것이 가장 큰 장점.

어떤 문제점이 있는 것들은 누적시키는게 아니라 계속해서 해결해 나가는 방식

소프트웨어개발시 많이 사용하는 방식

19)
Continuous Integration(CI)
데일리빌드에 더 나아가서, 하루에 한번이 아니라 어떤 커밋이 shared server에 푸쉬될때 또는 체크인 될때마다 하루에 몇번이건 통합해 나가는 방식.
다양한 환경에서 다양한 종류의 자동화된 테스트방법을 지원하고, 그 테스트결과를 사용자에게 notice하는 것을 다 포함하는 도구

구조
![오픈소스 6주차(OSS 3,4)-2](images/오픈소스%206주차(OSS%203,4)-2.png)

CI에서 핵심은 모든 커밋이 빌드되고 테스트된다.
개발환경 뿐만아니라 실제환경에서 제품이 테스트되는 장점, 목표
최신 빌드된 결과물을 모든 사람이 쉐어할 수 있다.
이런것들이 궁극적인 목표

21)
Version Control System

Daily Build나 Continuous Integration같은 방법은 빌드와 테스트가 빈번하다.
빌드시스템이 빌드한다는 것은 쉐어드서버에 올리고 공유한다는 개념이고, 그 모듈/파일의 버전은 업데이트 되어야함을 의미

CI는 굉장히 버전이 많은 문제가 있고, 버전이 많은 것을 관리하기위한 버전컨트롤시스템이 사용된다.

알려진 버전컨트롤시스템 -> CVS, subversion, git
최근에는 git이 사용률이 가장 많다.

이런 버전컨트럴시스템의 핵심기능은 
모든 종류의 파일에 대해 수정된 내용과 버전을 트래킹하는 기능
핵심기능은 파일들의 변화, 즉 특정시점에서의 수정내용, 특정시점과의 차이 등을 볼 수 있다는 점
심지어 특정시점으로 recovery하는 기능도 제공
또 branch 기능으로 다양하게 관리가능

22)
전형적으로 2가지 모델로 구현

Lock-modify-unlock model
라킹 메커니즘을 사용해서 레퍼지토리에 수정하고자할때 한번에 한사용자만 그 파일을 수정하도록.
lock을 check-out이라고도함. 수정하기위해 라킹을 건다는 뜻.
unlock은 check-in

대표적으로 ms사의 소스세이프같은 것들이 있는데,
문제점은 사용자가 개발할때 일반적으로 여러개의 파일을 동시에 다루는데, check-in을 하기전까지 다른 사용자가 접근하지 못하므로 다양한 문제가 발생..
그동안에 다른사람이 작업을 못함

copy-modify-merge model
라킹하지않고 카피해서 수정해서 합쳐나가는.
카피본을 만들어서 각자 자유롭게 수정하자.

문제점은 체크인할 때, 여러 사람이 write하면 날라갈 수도 있는데, 그래서 merge를 해야한다. 마지막으로 체크인하는사람이 일반적으로 책임을 져야하고 일관성을 유지하는 이슈가 있다.

정리
CI를 통해서 자주 빌드 및 테스트를 함 -> 버전이 업데이트 자주됨-> 버전컨트롤시스템이 필요

————————

OSS Tools II
Testing and Debugging in Python

2)
-디버거의 개념
-파이썬의 디버거 : pdb
-파이썬에서 제공하는 유닛테스트(디버깅과 뗄 수 없는 관계)
-pdb의 핵심기능들

3)
디버거
어떤 프로그램이 실행될때나 크래쉬됐을 때 그 프로그램의 내부가 어떻게 돌아가고 있는지, 컴퓨터가 실행하는 방식으로 동일하게 동작원리를 파악할 수 있는 기능을 제공하는 sw도구

주요기능
프로그램을 run하고 실행을 컨트롤(한스텝 가라던지, 저기서 중단하라던지..)
중단되었을 때 메모리나 변수, 인자의 값 확인 가능
어떤 조건에서 멈추도록하는 conditional breakpoint 제공

오류를 찾는데 사용되기도 하지만, 다른 사람이 짠 코드를 정확히 이해하는데 동적분석의 용도로 사용되기도 한다.

4)
파이썬의 디버거 : pdb(스탠다드 라이브러리에 포함)
크게 2가지 방식
-프롬프트에서 사용자와 커맨드라인으로 상호작용하는 Interactive command-line debugger
-비쥬얼 스튜디오같은 IDE에서 사용할 수 있는 GUI 디버거

pdb를 수행하는 방법 2가지
-하드코딩하는 방법. breakpoint() 함수를 이용하여 명시적으로 중단시킴.
-소스코드의 수정없이 pdb 사용가능 “-m pdb”

5)
디버거의 목적 : 디버깅 또는 동적 분석

디버깅할때 일반적으로 거치는 4가지 단계
위의 error propagation을 생각해보자.
![오픈소스 6주차(OSS 3,4)-3](images/오픈소스%206주차(OSS%203,4)-3.png)

Test
에러를 찾는 행위. 다양한 인풋으로 coverage를 100퍼센트로 하는 것이 목표

Stabilize
에러가 발생하도록 항상 그 컨디션이나 스테이트를 유지하는것.

Localize
오류가 발생하는 스테이트를 만들고 fault를 찾기 위해 범위를 좁혀가는 단계. 결국 근본원인인 fault를 찾는 단계.

Correction
fault를 해결

6)
디버깅할 때 제일먼저 고려해할 것은 테스트.
자신이 짠 코드를 모든 라인에 대해, 모든 path에 대해 테스트 하는 것을 Unit Test라고 한다.
목적은 에러를 최대한 빨리 찾는 것
파이썬은 기본적으로 unittest를 제공하기도하고 pytest같은 도구를 사용할 수도 있다

7)
pdb 명령어

help
지원 가능한 명령어 보여줌

gdb와 거의 비슷하나 파란색 네모가 gdb랑 차이점

8)
브레이크를 이용한 하드코딩 이용방법
파이썬 3.7 이전 : import pdb; pdb.sett_trace() 사용
3.7 이후 : breakpoint()

9)
소스코드의 수정없이 하는 방법
실행시 -m pdb
첫 문장부터 중단시킴

10)
사전적으로 알아야할 내용

파이썬 내부에서 관리하는 변수
__name__ : 현재 수행중인 모듈의 이름을 저장하는 변수
__file__ :  현재 수행중인 모듈의 전체 경로를 저장하는 변수

40:20~36:48 실습영상

11)
파이썬의 콜스택

콜스택 : 스택 프레임들의 집합. 함수가 호출될 때 한 새로운 스택 프레임이 생겨서 콜스택에 쌓이고, 함수가 호출이 종료되면 프레임이 자동적으로 사라지는 방식으로 동작

그림의 예시.

12)
여러개의 모듈이 있는데 중단되었을 때 호출레벨을 알 필요가 있다.
그 때 사용하는 명령어 -> w(where) or bt(back-trace) : 현재 스택프레임의 내용을 출력하는 명령어

가장 아래의 스택이 가장 최근 스택 
![오픈소스 6주차(OSS 3,4)-4](images/오픈소스%206주차(OSS%203,4)-4.png)

13)
콜스택에서 자유롭게 업다운 가능 -> u, d 커맨드
뒤에 오는 숫자는 컨트롤할 수 있는 인자. 디폴트는 1

가장 최근 스택에서 d하면 더 내려갈 곳이 없음

u나 d를 했을 때 해당 레벨의 지역변수 등에 접근가능

32:29~28:22 실습영상

14)
l 명령어. 소스코드를 볼 수 있음

…

25:25~22:42 실습영상

15)
변수나 expression을 확인하는 방법

20:11~16:51 실습영상

16)
breakpoint 명령어

15:13~12:50 실습영상

17)
실행명령어들

⭐️unt 명령어

9:05~6:38 실습영상

18)
conditional breakpoint

3:33~):49

19)
pdb이외의 도구들

